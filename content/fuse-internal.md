+++
title = "FUSE の内部動作"
date = 2019-12-25
draft = true

[taxonomies]
tags = [ "fuse", "filesystem", "linux" ]
categories = [ "programming" ]
+++

`polyfuse` を実装する上で溜まった知見を放流しておく。

正確性の保証は無し。

<!-- more -->

# 用語

* FUSE カーネルモジュール
    - FUSE ファイルシステムデーモンと VFS との橋渡しなど、ファイルシステムにおけるカーネル側の処理を担当するモジュール
        + ソースはカーネルに取り込み済みであり、カーネルのソースにパッチを当てる必要は（基本的には）ない
		+ FUSE デバイスと、`fuse` / `fusedev` ファイルシステムタイプを提供する
* FUSE ファイルシステムデーモン
    - ユーザ空間で動作し、ファイルシステムのデータ・メタデータを提供するプロセス。
        + FUSE デバイスを介してカーネルモジュールとデータをやり取りする。
* FUSE デバイス
    - FUSE カーネルモジュールが提供する、ファイルシステムデーモンとの通信を行うためのキャラクタデバイス
    - `modprobe fuse` すると `/dev/fuse` に現れる

# FUSE ファイルシステムデーモンの実行手順

* FUSE カーネルモジュールとの接続を確立する
    - `/dev/fuse` をオープンし、ファイルディスクリプタを得る
	- `mount(2)` システムコールを呼び、FUSE デバイスとマウントポイントを紐づける
* 次の手順を逐次的に繰り返す
    - カーネル側のキューに蓄えられているリクエストを FUSE デバイスを介して受信する
	- リクエストデータを解析し、その内容に基づきファイルシステムとしての処理を行う
    - 対応するリクエストへのレスポンスを FUSE デバイスを返してカーネルに送信する

## カーネルとの接続確立

FUSE ファイルシステムデーモンは、FUSE デバイスを介してカーネルとの通信を行う事でファイルシステムとして必要となるデータ・メタデータをカーネル側に提供する。
FUSE デバイスは通常のキャラクタデバイスであり、そのデバイスファイルは `fuse` モジュールをロードすることで `/dev/fuse` に公開される。
ファイルシステムデーモンは、起動時にまずこのデバイスファイルを `open` し、そのファイルディスクリプタを得る必要がある。
このファイルディスクリプタは、`mount` システムコールを用いることで指定されたマウントポイントを紐づけられる。

`mount` の呼び出しには `CAP_SYS_ADMIN` ケーパビリティが必要であるため、権限を持たない非特権ユーザはこの手順で接続を確立することが出来ない。
そのため、実際には setuid が付与されたマウント用のバイナリを用いて上記手順を実行し、それにより得られたファイルディスクリプタを `sendmsg`/`recvmsg` により受け取る事で接続を得る。マウント用のユーティリティである `fusermount` は、各 Linux ディストリビューションが提供する `fuse` パッケージをインストールするか、`libfuse` のソースをビルドすることで利用可能になる。

## カーネルとの通信

FUSE デバイスを介して行われるカーネルとの通信は単純な wire protocol であり、そのデータフォーマットは次のヘッダファイルで規定されている。

* (kernel) [`fuse.h`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/fuse.h?tag=v5.3.0)
* (libfuse) [`fuse_kernel.h`](https://github.com/libfuse/libfuse/tree/v3.8.0/include/fuse_kernel.h)

リクエストの受信は、先ほど開いた FUSE デバイスのファイルディスクリプタに対し `read(2)` などのシステムコールを呼び出すことで行われる。
各リクエストは、次のようなヘッダー部を持つ。

```c
struct fuse_in_header {
    uint32_t    len;
    uint32_t    opcode;
    uint64_t    unique;
    uint64_t    nodeid;
    uint32_t    uid;
    uint32_t    gid;
    uint32_t    pid;
    uint32_t    padding;
}
```

`len` はヘッダを含むリクエストの総データサイズ、`opcode` はリクエストの操作の種類を表す整数値である（指定される値は `fuse_opcode` が用いられる）。
`unique` は各リクエストに割り当てられる一意の識別子であり、送信されるレスポンスを区別するためなどに用いられる。
`nodeid` はリクエストの対象となる inode 番号、`uid`, `gid` および `pid` はリクエストを発行したプロセスの UID/GID/PID である。

リクエストの受信は、`read`/`readv` により逐次的に行われる。
このとき、ひとつのリクエストの受信は一回のシステムコールで完了する必要があり、受信側は（任意の種類のリクエストが格納できる）十分な大きさのバッファを用意する必要がある。
リクエストデータを読み込むバッファのサイズが要件を満たさないときは `EINVAL` が返される。
一度のリクエスト受信に必要な最小のバッファサイズは `max(sizeof(struct fuse_in_header) + sizeof(struct fuse_write_in) + max_write, FUSE_MIN_READ_BUFFER)` で算出される（ここで `max_write` は `FUSE_INIT` リクエスト時に指定されるパラメータのひとつ）。

カーネルへのレスポンスは、次のようなヘッダ部を持つ。

```c
struct fuse_out_header {
    uint32_t len;
    int32_t  error;
    uint64_t unique;
}
```

`len` はヘッダを含む送信されるデータの総サイズであり、送信されるデータの長さが `len` と一致しない場合は `EINVAL` が返される。
`error` はリクエストに対する処理がエラーとなった場合のエラー番号を指定するためのフィールドであり、対応する errno の**符号を反転させた値**を指定する。
`unique` フィールドには、対応するリクエストの `fuse_in_header` で渡されたものと同じ値を設定する。

各レスポンスは `unique` フィールドにより区別されるため、ファイルシステムは複数のリクエストを多重的に処理し、それらの応答を非同期的に送信することが出来る。

# リクエストの処理

TODO

## `FUSE_FORGET

TODO

# 割り込み

TODO

# カーネルへの通知

TODO
